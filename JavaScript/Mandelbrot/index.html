<!-- Hosted version http://pastehtml.com/view/c06ceb3bi.html -->
<html>
<header>
<style type="text/css">
    body {
      margin: 0;
      padding: 0;
      background-color: black;
    }
</style>
<script type="text/javascript">

  const MAX_VALUE = 4.0;
  const MAX_ITERATIONS = 30;
  const MAX_COLOR = 255;
  const COLOR_SCALE = Math.floor(MAX_COLOR / MAX_ITERATIONS);

  const getColor = (pointX, pointY) => {
    let i = 0;
    let x = 0;
    let y = 0;
    while ((i < MAX_ITERATIONS) && (x * x + y * y < MAX_VALUE)) {
      const xOfSquare = x * x - y * y;
      const yOfSquare = 2 * x * y;
      x = xOfSquare + pointX;
      y = yOfSquare + pointY;
      i++;
    }
    return getColorForIteration(i);
  }

  const getColorForIteration = (iterationNumber) => {
    return Math.min(iterationNumber * COLOR_SCALE, MAX_COLOR);
  }

  const main = () => {
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");

    canvas.setAttribute('width', window.innerWidth);
    canvas.setAttribute('height', window.innerHeight);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const minSize = Math.min(width, height);

    const updateCanvasStep = 50;

    const fontSizePx = 18;

    context.font = fontSizePx + 'px Arial';

    const imageData = context.getImageData(0, 0, width, height);

    function drawPixel(x, y, color) {
      let index = (x + y * width) * 4;
      imageData.data[index + 0] = color;
      imageData.data[index + 1] = color;
      imageData.data[index + 2] = color;
      imageData.data[index + 3] = 255;
    }

    function showComputationBorder(y) {
      context.fillRect(0, y, width, 1);
    }

    function updateCanvas() {
      context.putImageData(imageData, 0, 0);
    }

    function showProgress(progress, pixelsPerSecond) {
      context.fillStyle = 'green';
      context.fillText("Computing Mandelbrot set... " + progress.toFixed(2) + "%" + " Speed " + pixelsPerSecond + "K pixels/second ", 20, 20);
    }

    function hideProgress(progress) {
      context.fillStyle = 'black';
      context.fillText("Finished!", 20, 20);
    }

    const linePercentage = (1 / height) * 100;
    let totalProgress = 0;
    const startTime = new Date().getTime();

    for (let y = 0; y < height; y++) {
      const lineData = context.getImageData(0, y, width, 1);

      setTimeout((y) => {
        for (let x = 0; x < width; x++) {
          const scaledX = (4 * x / minSize) - (2 * width) / minSize;
          const scaledY = (4 * y / minSize) - (2 * height) / minSize;

          const color = getColor(scaledX, scaledY);
          drawPixel(x, y, color);
        }

        totalProgress += linePercentage;

        if ((y % updateCanvasStep === 0) ||Â (y === height - 1)) {
          updateCanvas();
          const elapsedTime = new Date().getTime() - startTime;
          const thousandPixelsPerSecond = Math.floor((((y + 1) * width) / elapsedTime));

          if (y < height - 1) {
            showComputationBorder(y);
            showProgress(totalProgress, thousandPixelsPerSecond);
          } else {
            hideProgress();
          }
        }
      }, 0, y);
    }

    //TODO: Re-factor, set-up a small project, compile code with Babel to ES5, bundle with HTML?
  }

  window.addEventListener('load', main);
</script>
</header>
<body>
    <canvas></canvas>
</body>
</html>